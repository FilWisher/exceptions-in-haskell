\chapter{Background}

This chapter explores what \emph{formal systems} are and what they are useful for. It looks at a number of related formal systems and their relation to computation. It outlines context ontop of which the rest of this project is built.

\section{Formal Systems}

\subsection{Domain Modelling}
\subsection{Derivation Rules}
\subsection{Derivation Strategies}

\section{\lam-Calculus}

\subsection{Syntax}

  \begin{figure}[!h]
  \definition{ 
    \textsc{(Grammar for untyped \lam-calculus)}
    \item $`l$-variables are denoted by $x, y,\dots$ \\
    \[
    \begin{array}{rcl}
    M,N & ::= & x\ |\ `lx.M\ |\ M\ N
    \end{array}
    \]
  }
  \end{figure}

\subsection{Reduction Rules}

  \begin{figure}[!h]
  \definition{ 
    \textsc{(Reduction rules for \lam-calculus)}
    \[
    \begin{array}{rcl}
    x & \rightarrow & x \\
    `lx.M & \rightarrow & `lx.M \\
    (`lx.M) N & \rightarrow & M[N/x]
    \end{array}
    \]
  }
  \end{figure}

\subsection{Reduction Strategies}

  \section{Logic and Types}
  \subsection{Logic Systems}
  \subsubsection{Intuitionistic}
  \subsubsection{Classical}
  \subsubsection{Sequent}

  \subsection{Type Assignment}

  \subsection{Curry-Howard Isomophism}

\section{Haskell}
  % TODO: purity and laziness
  \subsection{Data Types}
  \subsection{Type Level/Value Level}
  \subsection{Term Rewriting}
  % explain monads as generalizations of cps-terms
  % what they encode and why they are useful

\section{Continuations}
  \subsection{Delimited-Continuations}
  \subsection{Continuation-Passing Style}
  \subsection{Monads}

\section{\lmu-Calculus}
  \subsection{Syntax}
  \subsection{Reduction Rules}
  \subsection{Reduction Strategies}
  \subsection{Isomorphism \& Computational Interpretation}

\begin{figure}[!h]
\definition{ 
  \textsc{(Grammar for \lmu-calculus)}
  \item $`l$-variables are denoted by $x, y,\dots$ and $`m$-variables are denoted by $`a, `b,\dots$ \\
  \[
  \begin{array}{rcl}
  M,N & ::= & x\ |\ `lx.M\ |\ M\ N\ |\ `m`a.[`b]M
  \end{array}
  \]
}
\end{figure}

\begin{figure}[!h]
\definition{ 
  \textsc{(Reduction rules for \lmu-calculus)}
  \[
  \begin{array}{rcl}
  x & \rightarrow & x \\
  `lx.M & \rightarrow & `lx.M \\
  `m`a.[`b]M & \rightarrow & `m`a.[`b]M \\
  (`lx.M) N & \rightarrow & M[N/x] \\
  (`m`a.[`b]M) N & \rightarrow & (`m`a.[`b]M[[`g]M^\prime N/[`a]M^\prime]) \\
  \end{array}
  \]
}
\end{figure}

The terse reduction rule at the end simple states that the application of a \lmu-abstraction $`m`a.M$ to a term $N$ applies all the sub-terms of $M$ labelled $[`a]$ to $N$ and relabels them with a fresh $`m$ variable.

\section{\ltry-Calculus}

\section{Delimited-Continuation Calculus}

  Simon Peyton-Jones \textit{et al.}\ extended the \lam-calculus with additional operators in order create a framework for implementing delimited continuations \cite{JonesDS07}. This calculus will be referred to as the delimited-continuation calculus or DCC. Many calculi have been devised with control mechanisms. Like the \lmu-calculus, these control mechanisms are all specific instances of delimited and undelimited continuations. DCC provides a set of operations that are capable of expressing many of these other common control mechanisms.

  The grammar of DCC is an extension of the standard \lam-calculus:

  \subsection{Syntax}
  \begin{figure}[!h]
  \definition{ 
    \textsc{(Grammar for DCC)}
    \[
    \begin{array}{lrcl}
    \textrm{(Variables)} & x, y, \dots \\
    \textrm{(Expressions)} & e & ::= & x\ |\ `lx.e\ |\ e\ e^\prime \\
                           &   &  |  &  newPrompt\ |\ pushPrompt\ e\ e \\
                           &   &  |  &  withSubCont\ e\ e\ |\ pushSubCont\ e\ e
    \end{array}
    \]
  }
  \end{figure}

  \subsection{Reduction Rules}
  The operational semantics can be understood through an abstract machine that transforms tuple of the form $\langle e,\ D,\ E\, q \rangle$:

  \begin{figure}[!h]
  \relscale{0.9}
  \definition{ 
    \textsc{(Operational semantics for DCC)}
    \[
    \begin{array}{lrcl}
      \langle e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[\square\ e^\prime], E, q \rangle &\text{e non-value} \\
      \langle v\ e, D, E, q \rangle &\Rightarrow &\langle e, D[v\ \square], E, q \rangle &\text{e non-value} \\
      \langle pushPrompt\ e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[pushPrompt\ \square\ e^\prime], E, q \rangle &\text{e non-value} \\
      \langle withSubCont\ e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[withSubCont\ \square\ e^\prime], E, q \rangle &\text{e non-value} \\
      \langle withSubCont\ p\ e, D, E, q \rangle &\Rightarrow &\langle e, D[withSubCont\ p\ \square], E, q \rangle &\text{e non-value} \\
      \langle pushSubCont\ e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[pushSubCont\ \square\ e^\prime], E, q \rangle &\text{e non-value} \\
    \\
      \langle (`lx.e)\ v, D, E, q \rangle &\Rightarrow &\langle e[v/x], D, E, q \rangle \\
      \langle newPrompt, D, E, q \rangle &\Rightarrow &\langle q, D, E, q+1 \rangle \\
      \langle pushPrompt\ p\ e, D, E, q \rangle &\Rightarrow &\langle e, \square, p : D : E, q \rangle \\
      \langle withSubCont \ p\ v, D, E, q \rangle &\Rightarrow &\langle v (D : E\textsmaller[1]{\overset{p}{\uparrow}}, \square, E\textsmaller[1]{\overset{p}{\downarrow}}, q \rangle \\
      \langle pushSubCont E^\prime\ e, D, E, q \rangle &\Rightarrow &\langle e, \square, E^\prime +{+} (D : E), q \rangle \\
    \\
      \langle v, D, E, q \rangle &\Rightarrow &\langle D[v], \square, E, q \rangle \\
      \langle v, \square, p : E, q \rangle &\Rightarrow &\langle v, \square, E, q \rangle \\
      \langle v, \square, D : E, q \rangle &\Rightarrow &\langle v, D, E, q \rangle
    \end{array}
    \]
  }
  \end{figure}
  
  \subsection{Significance}

  % TODO: ensure prompts and continuation stack has been explained before reaching this point
  The additional terms behave as follows:
  \begin{itemize}
  \item \op{newPrompt} returns a new and distinct prompt.
  \item \op{pushPrompt}'s first argument is a prompt which is pushed onto the continuation stack before evaluating its second argument. 
  \item \op{withSubCont} captures the subcontinuation from the most recent occurrence of the first argument (a prompt) on the excution stack to the current point of execution. Aborts this continuation and applies the second argument (a \lam-abstraction) to the captured continuation.
  \item \op{pushSubCont} pushes the current continuation and then its first argument (a subcontinuation) onto the continuation stack before evaluating its second argument.
  \end{itemize}
