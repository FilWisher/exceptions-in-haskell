\chapter{DCC Interpreter}

This chapter explores the implementation of an interpreter for DCC. Portions of source code are examined in detail although the full source can be found in the appendix.

\section{Interpreter}

Although Peyton-Jones \emph{et al.} implement a language-level module for DCC, 
we are interested in the intermediate term transformations.
Using the step-by-step transformations produced by this interpreter,
we can construct and verify the implementations of \ltry\ and \lmu\ into DCC.
Examining transformation steps in full also allows us to derive proofs of soundness and completeness for these translations. 
For this reason, the interpreter was implemented as a term-rewriting program.

\section{Implementation}

\subsection{Data structures}
There are two data types for representing DCC terms, \mono{Value} and \mono{Expr}
(Figure \ref{fig:dcc-data-structures}).
Values are not evaluated: when a term has been reduced to a value, 
it has terminated on that value. 
An expression (\mono{Expr}) is a term that can be evaluated to another term. 
The only exception is a \mono{Hole} which can take any position an expression can. 
For this reason, it must be a data constructor for expression types.

The core of the abstract machine is a function from one state to the next. 
A state is its own data type which corresponds to the tuple from the specification of the semantics of the abstract machine $\langle e,\ D,\ E,\ q\rangle$:

\begin{figure}[!h]\label{fig:dcc-data-structures}
\Verbatimcode
data Value = Var Char
  | Abs Char Expr
  | Prompt Int
  | Seq [Expr]
  deriving (Show, Eq)
  
data Expr = Val Value 
  | App Expr Expr
  | Hole
  | PushPrompt Expr Expr
  | PushSubCont Expr Expr
  | WithSubCont Expr Expr
  | NewPrompt
  
  | Sub Expr Expr Char
  deriving (Show, Eq)

data State = State Expr Expr [Expr] Value
  deriving (Show, Eq)
\end{Verbatim}
\end{figure}

\subsection{Utility Functions}
Some utility functions are simplify the implementation.
Informally, these functions behave as follows (see Figure ~\ref{fig:dcc-helper-functions} for implementations details):

\begin{itemize}\itemsep0.1cm

\item \mono{prettify :: Expr -> String} is defined inductively for pretty-\\ printing terms.

\item \mono{ret :: Expr -> Expr -> Expr} returns the first expression with any holes filled in by the second expression.

\item \mono{composeContexts :: [Expr] -> Expr} takes a sequence of expressions and, starting from the end, 
fills the hole of each expression with the previous expression. 
This in effect joins the output of each context with the input of the next context.

\item \mono{promptMatch :: Int -> Expr -> Bool} returns true if the second argument is a Prompt with the same value as the first argument

\item \mono{splitBefore :: [Expr] -> Int -> [Expr]} returns the sequence of expressions up until (but not including) the prompt matching the second argument.

\item \mono{splitAfter :: [Expr] -> Int -> [Expr]} returns the sequence of expressions from (but not including) the prompt matching the second argument.

\item \mono{sub :: Expr -> Expr -> Char -> Expr} returns the first expression with all occurences of the third expression replaced by the second expression. 
If we name the arguments \mono{sub M V x} then this corresponds to the result of evaluating the substitution notation $M[v/x]$.

\end{itemize}

\begin{figure}[!h]\label{fig:dcc-helper-functions}
\Verbatimcode

  ret :: Expr -> Expr -> Expr
  ret d e = case d of
    Hole -> e
    App m n -> App (ret m e) (ret n e)
    Val (Abs x m) -> Val $ Abs x (ret m e)
    PushPrompt m n -> PushPrompt (ret m e) (ret n e)
    WithSubCont m n -> WithSubCont (ret m e) (ret n e)
    PushSubCont m n -> PushSubCont (ret m e) (ret n e)
    otherwise -> d

  composeContexts :: [Expr] -> Expr
  composeContexts = foldr ret Hole . reverse

  sub :: Expr -> Expr -> Char -> Expr
  sub m v x = case m of
    Val (Var n) -> if n == x then v else m
    Val (Abs y e) -> Val (Abs y $ sub e v x)
    Val (Prompt p) -> Val (Prompt p)
    App e e' -> App (sub e v x) (sub e' v x)
    NewPrompt -> NewPrompt
    PushPrompt e e' -> PushPrompt (sub e v x) (sub e' v x)
    WithSubCont e e' -> WithSubCont (sub e v x) (sub e' v x)
    PushSubCont e e' -> PushSubCont (sub e v x) (sub e' v x)

  promptMatch :: Int -> Expr -> Bool
  promptMatch i p = case p of
    (Val (Prompt p')) -> i == p'
    otherwise -> False
 
  splitBefore :: [Expr] -> [Expr]
  splitBefore p es = takeWhile (not . promptMatch p) es

  splitAfter :: [Expr] -> [Expr]
  splitAfter  p es = case length es of
    0 -> []
    otherwise -> tail list
    where list = dropWhile (not . promptMatch p) es
\end{Verbatim}
\caption{Utility functions for DCC interpreter}
\end{figure}

% TODO: make this section a little more structured
\subsection{Reduction Rules}

The heavy lifting of the interpreter is done by the function \mono{eval :: State -> State}. 
\mono{eval} is defined inductively on the structure of DCC terms. 
Using pattern-matching, each case of \mono{eval} corresponds directly to at least one of the reduction rules of the DCC abstract machine. 
For the full implementation of \mono{eval}, see Figure \ref{fig:dcc-eval}

The \mono{App e e'} case deals with applications:
if both terms are values and the first term is an abstraction of the form \mono{$`l$x.m}, 
the dominant term becomes a substitution of \mono{e'} for \mono{x} in \mono{m}. 
Otherwise, the term that is not a value is made the dominant term and the remainder of the application is added to the current context. 
If both terms are redexes, the left-most is made the dominant term first. 
In effect, an application first ensures the left-hand term has been evaluated fully before evaluating the right-hand term.

The \mono{PushPrompt e e'} case ensures the left term is a value.
It then pushes the first argument (a prompt) and the current context onto the stack and makes the second argument the dominant term. 

The reduction rules for \mono{WithSubCont e e'} ensure that the first argument has been evaluated to a prompt \mono{p} and then that the second argument has been evaluated to an abstraction. 
Finally, it appends the current continuation to the sequence yielded by splitting the continuation stack at \mono{p}, 
and creates an application of the second argument to this sequence.

Reducing \mono{PushSubCont e e'} ensures that the first argument is a sequence.
Then it pushes the current continuation, followed by this sequence, onto the stack.
The second argument is promoted to be the dominant term.
This has the effect of evaluating the dominant term and return the result to the sequence.

The reduction of \mono{Sub e y x} uses \mono{sub} to recursively substitute the third argument for the second in the first. 

Evaluating a \mono{Seq} transforms the sequence into an abstraction using \mono{seqToAbs}. This corresponds to the reduction rule we introduced in Figure \ref{fig:sequence-to-abstraction}:

Evaluated a value returns the value to the current continuation if there is one or pulls a continuation off the stack if there is not. If the stack is empty, nothing happens.

Evaluating \mono{NewPrompt} places the value of the current prompt as the dominant term and increments the global prompt counter:

\input{eval}

%TODO: evaluation of different implementation approaches
