\chapter{DCC Interpreter}

This chapter explores the implementation of an interpreter for DCC. Portions of source code are examined in detail although the full source can be found in the appendix.

\section{Interpreter}

Although Peyton-Jones \emph{et al.} implement a language-level module for DCC, 
we are interested in the intermediate term transformations. 
Examining transformation steps in full allows us to derive proofs of soundness and completeness for the translations from the \lam\ and \lmu\ calculi into DCC. 
For this reason, the interpreter was implemented as a term-rewriting program.

A sequence of contexts evaluates to an abstraction that, when applied to a value $v$, returns $v$ to the first context which returns its value to the second context and so on through the whole sequence.
 
\section{Implementation}

\subsection{Data structures}
There are two data types for representing DCC terms, \mono{Value} and \mono{Expr}:

\Verbatimcode
data Value = Var Char
  | Abs Char Expr
  | Prompt Int
  | Seq [Expr]
  deriving (Show, Eq)
  
data Expr = Val Value 
  | App Expr Expr
  | Hole
  | PushPrompt Expr Expr
  | PushSubCont Expr Expr
  | WithSubCont Expr Expr
  | NewPrompt
  
  | Sub Expr Expr Char
  deriving (Show, Eq)

data State = State Expr Expr [Expr] Value
  deriving (Show, Eq)
\end{Verbatim}

The core of the abstract machine is a function from one state to the next. A state is its own data type which corresponds to the tuple from the specification of the semantics of the abstract machine $\langle e,\ D,\ E,\ q\rangle$.

\subsection{Utility Functions}
Some utility functions are defined to help readability. See Figure ~\ref{fig:dcc-helper-functions} for implementations:

\begin{itemize}\itemsep0.1cm

\item \mono{prettify :: Expr -> String} is defined inductively for pretty-printing terms.

\item \mono{ret :: Expr -> Expr -> Expr} returns the first expression with any holes filled in by the second expression.

\item \mono{composeContexts :: [Expr] -> Expr} takes a sequence of expressions and, starting from the end, fills the hole of each expression with the previous expression. This in effect joins the output of each context with the input of the next context.

\item \mono{promptMatch :: Int -> Expr -> Bool} returns true if the second argument is a Prompt and has the same value as the first argument

\item \mono{splitBefore :: [Expr] -> Int -> [Expr]} 
\item \mono{splitAfter :: [Expr] -> Int -> [Expr]}
\item \mono{sub :: [Expr] -> Int -> [Expr]}

\end{itemize}

\begin{figure}[!h]\label{fig:dcc-helper-functions}
\Verbatimcode

  ret :: Expr -> Expr -> Expr
  ret d e = case d of
    Hole -> e
    App m n -> App (ret m e) (ret n e)
    Val (Abs x m) -> Val $ Abs x (ret m e)
    PushPrompt m n -> PushPrompt (ret m e) (ret n e)
    WithSubCont m n -> WithSubCont (ret m e) (ret n e)
    PushSubCont m n -> PushSubCont (ret m e) (ret n e)
    otherwise -> d

  composeContexts :: [Expr] -> Expr
  composeContexts = foldr ret Hole . reverse

  sub :: Expr -> Expr -> Char -> Expr
  sub m v x = case m of
    Val (Var n) -> if n == x then v else m
    Val (Abs y e) -> Val (Abs y $ sub e v x)
    Val (Prompt p) -> Val (Prompt p)
    App e e' -> App (sub e v x) (sub e' v x)
    NewPrompt -> NewPrompt
    PushPrompt e e' -> PushPrompt (sub e v x) (sub e' v x)
    WithSubCont e e' -> WithSubCont (sub e v x) (sub e' v x)
    PushSubCont e e' -> PushSubCont (sub e v x) (sub e' v x)

  promptMatch :: Int -> Expr -> Bool
  promptMatch i p = case p of
    (Val (Prompt p')) -> i == p'
    otherwise -> False
 
  splitBefore :: [Expr] -> [Expr]
  splitBefore p es = takeWhile (not . promptMatch p) es

  splitAfter :: [Expr] -> [Expr]
  splitAfter  p es = case length es of
    0 -> []
    otherwise -> tail list
    where list = dropWhile (not . promptMatch p) es
\end{Verbatim}
\caption{Utility functions for DCC interpreter}
\end{figure}

% TODO: make this section a little more structured
\subsection{Reduction Rules}

The heavy lifting is done by the function \mono{eval :: State -> State}. \mono{eval} is defined inductively on the structure of the current expression. Each case of \mono{eval} corresponds directly to at least one of the reduction rules of the DCC operational semantics. The full source can be found in the appendix: % which?

The first case deals with applications of the form \mono{e e'}. If both terms are values and the first term is an abstraction of the form \mono{$`l$x.m}, the dominant term becomes a substitution of \mono{e'} for \mono{x} in \mono{m}. Otherwise, the term that is a redex is made the dominant term and the remainder of the application is added to the current context. If both terms are redexes, the left-most is made the dominant first. In effect, an application first ensures the left-hand term has been evaluated fully before evaluating the right-hand term.  

This implements the following three reduction rules:
\[
\begin{array}{lrcl}
  \langle e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[\square\ e^\prime], E, q \rangle &\text{e non-value} \\
  \langle v\ e, D, E, q \rangle &\Rightarrow &\langle e, D[v\ \square], E, q \rangle &\text{e non-value} \\
  \langle (`lx.e)\ v, D, E, q \rangle &\Rightarrow &\langle e[v/x], D, E, q \rangle
\end{array}
\]

The following reduction rules for pushPrompt are implemented to ensure the first expression has been evaluated to a prompt:
\[
  \begin{array}{lcl}
    \langle pushPrompt\ e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[pushPrompt\ \square\ e^\prime], E, q \rangle \\
    \langle pushPrompt\ p\ e, D, E, q \rangle &\Rightarrow &\langle e, \square, p : D : E, q \rangle \\
  \end{array}
\]

The reduction rules for \mono{WithSubCont} ensure that the first argument has been evaluated to a prompt \mono{p} and then that the second argument has been evaluated to an abstraction. Finally, it appends the current continuation to the sequence yielded by splitting the continuation stack at \mono{p}, and creates an application of the second argument to this sequence.
\[
  \begin{array}{lcl}
\langle withSubCont\ e\ e^\prime, D, E, q \rangle &\Rightarrow &\langle e, D[withSubCont\ \square\ e^\prime], E, q \rangle\\
\langle withSubCont\ p\ e, D, E, q \rangle &\Rightarrow &\langle e, D[withSubCont\ p\ \square], E, q \rangle \\
\langle withSubCont \ p\ v, D, E, q \rangle &\Rightarrow &\langle v (D : E\textsmaller[1]{\overset{p}{\uparrow}}, \square, E\textsmaller[1]{\overset{p}{\downarrow}}, q \rangle \\
  \end{array}
\]

% TODO: here relevant to explain that sequence is forced into abstraction
Reducing \mono{PushSubCont} ensures that the first argument is a sequence, pushes the current continuation onto the stack, and then pushes the abstraction that represents the sequence onto the stack. The abstraction is first applied to a Hole. This is a hack to reverse the conversion of context-sequences into abstractions. This is necessary because context-sequences need to be abstractions when being applied but need to be sequences when being composed with other sequences of contexts.

The reduction of \mono{Sub} states is defined inductively on the structure of the first argument of dominant term. The base case replaces matching variables with the second term. The other cases ensure that substitution is propogated to the subterms. 

Evaluating a \mono{Seq} transforms the sequence into an abstraction using \mono{seqToAbs}. This corresponds to the reduction rule we introduced in Figure \ref{fig:sequence-to-abstraction}:

Evaluated a value returns the value to the current continuation if there is one or pulls a continuation off the stack if there is not. If the stack is empty, nothing happens.

Evaluating \mono{NewPrompt} places the value of the current prompt as the dominant term and increments the global prompt counter:

\input{eval}
